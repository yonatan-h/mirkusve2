<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>

		<style>
			#mirkusve-submit input {
				max-width: min-content;
			}
			.red-border {
				border: 5px solid orangered;
			}
		</style>
	</head>

	<body>
		<form id="mirkusve-submit">
			<p id="suggest-p"></p>
			<code id="suggest-c"></code>
			<h2>Submit to</h2>
			<p>
				<input type="text" name="submissions" placeholder="?" /> submissions |
				<input type="text" name="minutes" placeholder="?" /> minutes
			</p>
			<p>
				Select a folder in your repo to upload
				<input type="text" name="questionName" placeholder="?" />.
				<input type="text" name="fileExtension" placeholder="?" />
				<input type="text" name="file" placeholder="???" />
			</p>

			<div>
				<div id="tree-view"></div>
				<input type="text" name="folderPath" />
			</div>

			<input type="submit" value="Submit" />
		</form>

		<script>
			const submissionForm = document.getElementById("mirkusve-submit");
			submissionForm.onsubmit = handleAnswerSubmit;

			const suggestParagraph = submissionForm.querySelector("#suggest-p");
			const suggestCode = submissionForm.querySelector("#suggest-c");

			class SkipperError extends Error {}

			function handleIfNetworkError(error) {
				if (!(error instanceof TypeError)) throw error;
				let message = "You may be having connection issues";
				message += "<br/> Try again later";
				suggestParagraph.innerHTML = message;
				suggestCode.textContent = error.message;
			}

			function handleIfBadStatus(response) {
				if (response.ok) return response;

				const { ok, status, statusText, url } = response;
				suggestParagraph.textContent =
					"Http response has is not ok. Maybe turn off vpn, or try again later.";
				suggestCode.textContent = JSON.stringify({
					ok,
					status,
					statusText,
					url,
				});
				throw new SkipperError();
			}

			function handleIfRecentNotAccepted() {
				if (recentWasAccepted()) return;
				const message = "You need 'Accepted' solutions if you want to submit!";
				suggestParagraph.textContent = message;
				throw new SkipperError();
			}

			function handleIfAppscriptError(json) {
				if (!json.error) return json;

				suggestP.textContent = "Message from Sheets: " + json.error;
				suggestC.textContent = json.error;
				throw new SkipperError();
			}

			function swallowSkipperError(error) {
				if (!(error instanceof SkipperError)) throw error;
			}

			async function refresh() {
				suggestParagraph.textContent = "";
				suggestCode.textContent = "";

				disableSubmitButton();
				setMinutes();
				setSubmissions();
				setFile();
				setQuestionName();
				setFileExtension();

				return new Promise((suc) => suc())
					.then(handleIfRecentNotAccepted)
					.then(() => getFolderPaths(handleIfBadStatus))
					.catch(handleIfNetworkError)
					.then(showTreeView)
					.then(handleIfNetworkError)
					.then(enableSubmitButton)
					.catch(swallowSkipperError);
			}

			function enableSubmitButton() {
				submissionForm
					.querySelector('[type="submit"]')
					.removeAttribute("disabled");
			}

			function disableSubmitButton() {
				submissionForm
					.querySelector('[type="submit"]')
					.setAttribute("disabled", "disabled");
			}

			async function setMinutes() {
				const timeInput = submitForm.querySelector(`[name="time"]`);
				timeInput.value = 5;
			}

			function setSubmissions() {
				const submissionsInput =
					submitForm.querySelector(`[name="submissions"]`);

				const totalSubmissionCount = getSubmissionSpans().length;
				submissionsInput.value = totalSubmissionCount;
			}

			function getSubmissionSpans() {
				const selector = "span.text-green-s, span.text-red-s";
				//[...] because truthy falsey values are not as predicted
				return [...document.querySelectorAll(selector)];
			}

			function recentWasAccepted() {
				const submissionSpans = getSubmissionSpans();
				return submissionSpans[0]?.innerText === "Accepted";
			}

			function setFile() {
				const fileInput = submitForm.querySelector(`[name="file"]`);
				const fileContent = document.querySelector("code").innerText;
				submissionsInput.value = fileContent;
			}

			function setQuestionName() {
				const questionNameInput = submitForm.querySelector(
					`[name="questionName"]`
				);
				questionNameInput.value = "palindrome";
			}

			function setFileExtension() {
				const fileExtensionInput = submitForm.querySelector(
					'[name="fileExtension"]'
				);
				const extension = document.querySelector("code").className;
				fileExtensionInput.value = extension;
			}

			async function getFolderPaths(handleIfBadStatus) {
				const fetchProps = {
					method: "GET",
					headers: {
						Accept: "application/vnd.github+json",
						Authorization: "Bearer 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",
					},
				};

				const shaUrl =
					"https://api.github.com/repos/yonatan-h/dummy/commits/main";
				const shaResponse = await fetch(shaUrl, fetchProps);
				handleIfBadStatus(shaResponse);
				const sha = (await shaResponse.json()).sha;

				const treeUrl = `https://api.github.com/repos/yonatan-h/dummy/git/trees/${sha}?recursive=1`;
				const treeResponse = await fetch(treeUrl, fetchProps);
				handleIfBadStatus(treeResponse);
				const tree = (await treeResponse.json()).tree;

				const folderPaths = tree
					.filter((node) => node.type === "tree")
					.map((folder) => folder.path);
				return folderPaths;
			}

			async function showTreeView(folderPaths) {
				const treeViewDiv = submissionForm.getElementById("tree-view");
				treeViewDiv.innerHtml = "";
				folderPaths.sort(); // same parents together
				folderPaths.forEach(addFolderLabel);
			}

			function addFolderLabel(path) {
				const nodes = path.split("/").filter((node) => node !== "");
				const name = nodes ? nodes[nodes.length - 1] : "root";
				const depth = pathNodes.length;

				const label = submissionForm.createElement("span");
				label.textContent = name;
				label.classList.add("folder");

				const indentationUnit = 20;
				label.style.marginLeft = `${depth * indentationUnit}px`;
				label.onclick = () => handleLabelClick(label, path);

				const treeViewDiv = submissionForm.getElementById("tree-view");
				const labelContainer = submissionForm.createElement("div");
				labelContainer.appendChild(label);
				treeViewDiv.appendChild(labelContainer);
			}

			function handleLabelClick(label, path) {
				const treeViewDiv = submissionForm.getElementById("tree-view");
				const labels = [...treeViewDiv.querySelectorAll(".folder__selected")];

				labels.forEach((label) => label.classList.remove(selectedClass));
				label.classList.add(selectedClass);
				submissionForm.querySelector('[name="folderPath"]').value = path;
			}

			function remindSelectFolder() {
				const treeViewDiv = submissionForm.querySelector("#tree-view");

				treeViewDiv.classList.add("red-border");
				setTimeout(() => treeViewDiv.classList.remove("red-border"), 1000);
				alert("Please select a folder for your answer file");
			}

			async function answerCellsAreEmpty(questionName) {
				return true;
			}

			function extractKeyValues(form) {
				const formData = new FormData(form);
				const keyValues = {};
				for (const [key, value] of formData) {
					keyValues[key] = value;
				}
				return keyValues;
			}

			async function uploadToGithub(
				folderPath,
				fileName,
				fileExtension,
				file
			) {}

			async function submitToSheets(submissions, minutes) {}

			async function submit({
				submissions,
				minutes,
				folderPath,
				fileName,
				fileExtension,
				file,
			}) {
				await uploadToGithub(folderPath, fileName, fileExtension, file);
				await submitToSheets(submissions, minutes);
			}

			async function handleAnswerSubmit(event) {
				event.preventDefault();
				disableSubmitButton();

				const keyValues = extractKeyValues(submissionForm);
				if (keyValues["folderPath"] === "") {
					remindSelectFolder();
					enableSubmitButton();
					return;
				}

				for (const key in keyValues) {
					if (keyValues[key] === "") {
						alert(`field '${key}'' is empty`);
						enableSubmitButton();
						return;
					}
				}

				return answerCellsAreEmpty(questionName);

				if (!(await answerCellsAreEmpty(questionName))) {
					let message = `You've already answered '${questionName}' in the google sheets.`;
					alert(message);
					enableSubmitButton();
					return;
				}

				const json = JSON.stringify(keyValues);
				console.log(json);

				submissionForm.querySelector('[type="submit"]').textContent =
					"Submitted";
			}
		</script>
	</body>
</html>
