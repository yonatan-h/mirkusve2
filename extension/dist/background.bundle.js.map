{"version":3,"file":"background.bundle.js","mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://mirkusve2/./src/background/setup.js","webpack://mirkusve2/./src/background/view-request.js","webpack://mirkusve2/./src/utils/custom-errors.js","webpack://mirkusve2/./src/utils/keys.js","webpack://mirkusve2/webpack/bootstrap","webpack://mirkusve2/webpack/runtime/define property getters","webpack://mirkusve2/webpack/runtime/hasOwnProperty shorthand","webpack://mirkusve2/webpack/runtime/make namespace object","webpack://mirkusve2/./src/background/background.js"],"sourcesContent":["import { clientId } from '../utils/keys.js';\nimport { CustomError } from '../utils/custom-errors.js';\nfunction openSetupTab() {\n  const url = chrome.runtime.getURL('/setup.html');\n  chrome.tabs.create({\n    url\n  });\n}\nasync function getRedirectedUrl(name) {\n  await chrome.identity.clearAllCachedAuthTokens();\n  const authUrl = getAuthURL(name);\n  try {\n    const redirectedUrl = await chrome.identity.launchWebAuthFlow({\n      url: authUrl,\n      interactive: true\n    });\n    return {\n      redirectedUrl\n    };\n  } catch (error) {\n    const message = 'You canceled the sign in? Please sign in to github.';\n    const customError = new CustomError(message, error.message);\n    return {\n      error: customError\n    };\n  }\n}\nfunction getAuthURL(name) {\n  let authUrl = 'https://github.com/login/oauth/authorize';\n  authUrl += `?client_id=${clientId}`;\n  authUrl += `&login=${name}`;\n  return authUrl;\n}\nexport { openSetupTab, getRedirectedUrl };","async function requestViewChange(tabId, url) {\n  const viewName = await getViewName(url);\n  if (!inSlashProblems(url)) return;\n  chrome.tabs.sendMessage(tabId, {\n    message: 'change-view',\n    viewName\n  });\n}\nasync function getViewName(link) {\n  if (matchesQuestionPage(link)) return 'timer';else if (matchesSubmissionPage(link)) return 'answer-submit';else return undefined;\n}\nfunction inSlashProblems(url) {\n  const pathNodes = new URL(url).pathname.split('/').filter(x => x !== '');\n  const hasProblems = pathNodes[0] === 'problems';\n  return hasProblems;\n}\nfunction matchesSubmissionPage(url) {\n  //example\n  //https://leetcode.com/problems/two-sum/submissions/54654\n\n  const pathNodes = new URL(url).pathname.split('/').filter(x => x !== '');\n  const hasProblems = pathNodes[0] === 'problems';\n  const hasSubmissions = pathNodes[pathNodes.length - 2] === 'submissions';\n  return hasProblems && hasSubmissions;\n}\nfunction matchesQuestionPage(url) {\n  //examples\n  //https://leetcode.com/problems/two-sum/description/\n  //or\n  //https://leetcode.com/problems/two-sum/\n\n  const pathNodes = new URL(url).pathname.split('/').filter(x => x !== '');\n  const hasProblem = pathNodes[0] === 'problems';\n  const hasDescription = pathNodes[pathNodes.length - 1] === 'description';\n  const questionNameOnly = pathNodes.length === 2;\n  return hasProblem && (hasDescription || questionNameOnly);\n}\nexport default requestViewChange;","class CustomError extends Error {\n  constructor(descriptionAndSolution, errorAsString = \"\") {\n    super(`Custom Error: \\n- ${descriptionAndSolution}\\n- ${errorAsString}\\n`);\n    this.descriptionAndSolution = descriptionAndSolution;\n    this.errorAsString = errorAsString;\n  }\n}\nclass NetworkError extends CustomError {\n  constructor(typeError) {\n    const {\n      name,\n      message\n    } = typeError;\n    const errorAsString = JSON.stringify({\n      name,\n      message\n    });\n    super(\"Weak connection? Please try again later.\", errorAsString);\n  }\n}\nclass BadStatusError extends CustomError {\n  constructor(response) {\n    const {\n      ok,\n      status,\n      statusText,\n      url\n    } = response;\n    const errorAsString = JSON.stringify({\n      ok,\n      status,\n      statusText,\n      url\n    });\n    super(\"Http response not ok. Try avoiding vpn or try again later.\", errorAsString);\n  }\n}\nclass BadUrlError extends CustomError {\n  constructor(badUrl) {\n    super(`${badUrl} is not a valid url`);\n  }\n}\n\n//because (at least sofar) you cant send status codes in appscript responses\nclass AppScriptError extends CustomError {\n  constructor(responseObject) {\n    super(`Message from Sheets: ${responseObject.error}`);\n  }\n}\nclass EmptyInputError extends CustomError {\n  constructor(inputName) {\n    super(`Please fill out '${inputName}'`);\n  }\n}\nexport { CustomError, NetworkError, BadStatusError, AppScriptError, EmptyInputError, BadUrlError };","const clientId = 'Iv1.0c9196e6fcd3647a';\nconst githubAppId = 356032; //the github apps\nconst githubAppLink = 'https://github.com/apps/mirkusve/installations/new';\nconst mainWebappUrl = 'https://script.google.com/macros/s/AKfycbwztq78Ffh6hPaXVHECZloSnIDnSZ0CJYzjTy96KJ0prxna96NwSO1HoUs8XKIDuIRt/exec';\nconst codeForTokenUrl = mainWebappUrl + '?path=tokens';\nconst groupFinderUrl = mainWebappUrl + '?path=group-urls';\nconst getGroupWebappUrl = async () => {};\nconst getAnswerSubmitUrl = async () => {\n  return (await getGroupWebappUrl()) + '&path=answers';\n};\nexport { groupFinderUrl, clientId, codeForTokenUrl, getAnswerSubmitUrl, githubAppLink, githubAppId };","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { openSetupTab, getRedirectedUrl } from \"./setup.js\";\nimport requestViewChange from \"./view-request.js\";\n//All listeners should be exposed, not nested in functions (from the documentation)\n\nchrome.runtime.onMessage.addListener((req, sender, next) => {\n  if (req.message === \"set-up\") openSetupTab();\n});\nchrome.runtime.onMessage.addListener((req, sender, next) => {\n  if (req.message === \"sign-in\") {\n    getRedirectedUrl(req.userName).then(next);\n    return true;\n  }\n});"],"names":[],"sourceRoot":""}